<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JufipAI Performance Analysis Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0f172a, #1e293b);
            color: #f3f4f6;
            padding: 2rem;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .header h1 {
            font-size: 2.5rem;
            color: #3b82f6;
            margin-bottom: 1rem;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .metric-card {
            background: rgba(31, 41, 55, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            padding: 1.5rem;
            backdrop-filter: blur(10px);
        }

        .metric-title {
            font-size: 1.2rem;
            color: #60a5fa;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .metric-value.good { color: #10b981; }
        .metric-value.warning { color: #f59e0b; }
        .metric-value.poor { color: #ef4444; }

        .metric-description {
            font-size: 0.9rem;
            color: #9ca3af;
            line-height: 1.4;
        }

        .test-buttons {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .test-btn {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .test-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }

        .results {
            background: rgba(15, 23, 42, 0.9);
            border-radius: 12px;
            padding: 2rem;
            margin-top: 2rem;
        }

        .results h3 {
            color: #fbbf24;
            margin-bottom: 1rem;
        }

        .recommendation {
            background: rgba(59, 130, 246, 0.1);
            border-left: 4px solid #3b82f6;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .recommendation.high { border-left-color: #ef4444; }
        .recommendation.medium { border-left-color: #f59e0b; }
        .recommendation.low { border-left-color: #10b981; }

        .log {
            background: #000;
            color: #0f0;
            padding: 1rem;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 1rem;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(31, 41, 55, 0.8);
            border-radius: 3px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ JufipAI Performance Analysis</h1>
            <p>Comprehensive performance testing for the articles section implementation</p>
        </div>

        <div class="test-buttons">
            <button class="test-btn" onclick="runPageLoadTest()">üìä Page Load Analysis</button>
            <button class="test-btn" onclick="runAnimationTest()">üé¨ Animation Performance</button>
            <button class="test-btn" onclick="runMobileTest()">üì± Mobile Performance</button>
            <button class="test-btn" onclick="runAccessibilityTest()">‚ôø Accessibility Test</button>
            <button class="test-btn" onclick="runCoreWebVitals()">‚ö° Core Web Vitals</button>
            <button class="test-btn" onclick="runFullAnalysis()">üîç Full Analysis</button>
        </div>

        <div class="progress-bar" id="progressBar" style="display: none;">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="metrics-grid" id="metricsGrid">
            <!-- Metrics will be populated here -->
        </div>

        <div class="results" id="results" style="display: none;">
            <h3>üìã Analysis Results</h3>
            <div id="resultContent"></div>
            <div class="log" id="performanceLog"></div>
        </div>
    </div>

    <script>
        // Performance Analysis Tool
        class PerformanceAnalyzer {
            constructor() {
                this.metrics = {};
                this.recommendations = [];
                this.testLog = [];
                this.startTime = performance.now();
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                this.testLog.push(`[${timestamp}] ${message}`);
                const logElement = document.getElementById('performanceLog');
                if (logElement) {
                    logElement.innerHTML = this.testLog.join('\n');
                    logElement.scrollTop = logElement.scrollHeight;
                }
                console.log(`Performance Test: ${message}`);
            }

            updateProgress(percentage) {
                const progressFill = document.getElementById('progressFill');
                if (progressFill) {
                    progressFill.style.width = percentage + '%';
                }
            }

            showProgressBar() {
                document.getElementById('progressBar').style.display = 'block';
            }

            hideProgressBar() {
                document.getElementById('progressBar').style.display = 'none';
            }

            // Page Load Performance Analysis
            async analyzePageLoad() {
                this.log('Starting page load analysis...');
                const loadTime = performance.now() - this.startTime;

                // Analyze navigation timing
                const navigation = performance.getEntriesByType('navigation')[0];
                const resourceEntries = performance.getEntriesByType('resource');

                this.metrics.pageLoad = {
                    totalLoadTime: loadTime,
                    domContentLoaded: navigation ? navigation.domContentLoadedEventEnd - navigation.navigationStart : 0,
                    loadComplete: navigation ? navigation.loadEventEnd - navigation.navigationStart : 0,
                    firstPaint: this.getFirstPaint(),
                    resourceCount: resourceEntries.length,
                    largestResource: this.getLargestResource(resourceEntries),
                    totalResourceSize: this.getTotalResourceSize(resourceEntries)
                };

                this.log(`Page load completed in ${loadTime.toFixed(2)}ms`);
                this.log(`DOM Content Loaded: ${this.metrics.pageLoad.domContentLoaded.toFixed(2)}ms`);
                this.log(`Total resources loaded: ${this.metrics.pageLoad.resourceCount}`);
                this.log(`Total resource size: ${(this.metrics.pageLoad.totalResourceSize / 1024).toFixed(2)}KB`);

                return this.metrics.pageLoad;
            }

            getFirstPaint() {
                const paintEntries = performance.getEntriesByType('paint');
                const firstPaint = paintEntries.find(entry => entry.name === 'first-paint');
                return firstPaint ? firstPaint.startTime : 0;
            }

            getLargestResource(resources) {
                let largest = { name: 'none', size: 0 };
                resources.forEach(resource => {
                    if (resource.transferSize > largest.size) {
                        largest = { name: resource.name, size: resource.transferSize };
                    }
                });
                return largest;
            }

            getTotalResourceSize(resources) {
                return resources.reduce((total, resource) => total + (resource.transferSize || 0), 0);
            }

            // Animation Performance Analysis
            async analyzeAnimations() {
                this.log('Analyzing animation performance...');

                // Monitor frame rate during animations
                const frameRates = [];
                let frameCount = 0;
                let startTime = performance.now();

                return new Promise((resolve) => {
                    const measureFrameRate = () => {
                        frameCount++;
                        const currentTime = performance.now();
                        const elapsed = currentTime - startTime;

                        if (elapsed >= 1000) { // Measure for 1 second
                            const fps = Math.round((frameCount / elapsed) * 1000);
                            frameRates.push(fps);
                            frameCount = 0;
                            startTime = currentTime;

                            if (frameRates.length >= 3) { // Get 3 samples
                                const avgFps = frameRates.reduce((a, b) => a + b, 0) / frameRates.length;
                                this.metrics.animation = {
                                    averageFPS: avgFps,
                                    frameRates: frameRates,
                                    animationCount: this.countAnimations(),
                                    memoryUsage: this.getMemoryUsage()
                                };

                                this.log(`Average FPS: ${avgFps.toFixed(1)}`);
                                this.log(`Active animations: ${this.metrics.animation.animationCount}`);
                                resolve(this.metrics.animation);
                            } else {
                                requestAnimationFrame(measureFrameRate);
                            }
                        } else {
                            requestAnimationFrame(measureFrameRate);
                        }
                    };

                    requestAnimationFrame(measureFrameRate);
                });
            }

            countAnimations() {
                const animatedElements = document.querySelectorAll('[style*="animation"], .particle, .ai-agent, .robot, .article-card, .featured-article');
                return animatedElements.length;
            }

            getMemoryUsage() {
                if (performance.memory) {
                    return {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                    };
                }
                return null;
            }

            // Mobile Performance Analysis
            async analyzeMobilePerformance() {
                this.log('Analyzing mobile performance...');

                const isMobile = window.innerWidth <= 768;
                const touchSupport = 'ontouchstart' in window;

                // Simulate mobile viewport if not on mobile
                if (!isMobile) {
                    document.body.style.width = '375px';
                    window.dispatchEvent(new Event('resize'));
                }

                this.metrics.mobile = {
                    viewport: {
                        width: window.innerWidth,
                        height: window.innerHeight,
                        isMobile: isMobile
                    },
                    touchSupport: touchSupport,
                    networkSpeed: this.estimateNetworkSpeed(),
                    batteryAPI: 'getBattery' in navigator,
                    deviceMemory: navigator.deviceMemory || 'unknown'
                };

                this.log(`Mobile viewport: ${this.metrics.mobile.viewport.width}x${this.metrics.mobile.viewport.height}`);
                this.log(`Touch support: ${touchSupport}`);
                this.log(`Device memory: ${this.metrics.mobile.deviceMemory}GB`);

                return this.metrics.mobile;
            }

            estimateNetworkSpeed() {
                const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                if (connection) {
                    return {
                        effectiveType: connection.effectiveType,
                        downlink: connection.downlink,
                        rtt: connection.rtt
                    };
                }
                return null;
            }

            // Accessibility Analysis
            async analyzeAccessibility() {
                this.log('Analyzing accessibility features...');

                const focusableElements = document.querySelectorAll(
                    'a, button, input, textarea, select, [tabindex]:not([tabindex="-1"])'
                );

                const imagesWithoutAlt = document.querySelectorAll('img:not([alt])');
                const headingStructure = this.analyzeHeadingStructure();
                const ariaLabels = document.querySelectorAll('[aria-label], [aria-labelledby]');

                this.metrics.accessibility = {
                    focusableElements: focusableElements.length,
                    imagesWithoutAlt: imagesWithoutAlt.length,
                    headingStructure: headingStructure,
                    ariaLabels: ariaLabels.length,
                    keyboardNavigation: this.testKeyboardNavigation(),
                    colorContrast: this.analyzeColorContrast()
                };

                this.log(`Focusable elements: ${focusableElements.length}`);
                this.log(`Images without alt text: ${imagesWithoutAlt.length}`);
                this.log(`ARIA labels found: ${ariaLabels.length}`);

                return this.metrics.accessibility;
            }

            analyzeHeadingStructure() {
                const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
                const structure = {};

                headings.forEach(heading => {
                    const level = heading.tagName.toLowerCase();
                    structure[level] = (structure[level] || 0) + 1;
                });

                return structure;
            }

            testKeyboardNavigation() {
                // Basic keyboard navigation test
                const focusableElements = document.querySelectorAll(
                    'a, button, input, textarea, select, [tabindex]:not([tabindex="-1"])'
                );

                let tabOrder = [];
                focusableElements.forEach((element, index) => {
                    const tabIndex = element.tabIndex || 0;
                    tabOrder.push({ element: element.tagName, tabIndex: tabIndex });
                });

                return {
                    totalFocusable: focusableElements.length,
                    tabOrder: tabOrder
                };
            }

            analyzeColorContrast() {
                // Simplified color contrast analysis
                const textElements = document.querySelectorAll('p, h1, h2, h3, h4, h5, h6, span, a');
                let contrastIssues = 0;

                textElements.forEach(element => {
                    const styles = window.getComputedStyle(element);
                    const color = styles.color;
                    const backgroundColor = styles.backgroundColor;

                    // Simplified contrast check (would need proper WCAG calculation)
                    if (color === backgroundColor) {
                        contrastIssues++;
                    }
                });

                return {
                    elementsChecked: textElements.length,
                    potentialIssues: contrastIssues
                };
            }

            // Core Web Vitals
            async analyzeCoreWebVitals() {
                this.log('Measuring Core Web Vitals...');

                return new Promise((resolve) => {
                    // LCP (Largest Contentful Paint)
                    const lcpObserver = new PerformanceObserver((entryList) => {
                        const entries = entryList.getEntries();
                        const lastEntry = entries[entries.length - 1];
                        this.metrics.coreWebVitals = this.metrics.coreWebVitals || {};
                        this.metrics.coreWebVitals.lcp = lastEntry.startTime;
                        this.log(`LCP: ${lastEntry.startTime.toFixed(2)}ms`);
                        lcpObserver.disconnect();
                    });

                    if ('PerformanceObserver' in window) {
                        try {
                            lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
                        } catch (e) {
                            this.log('LCP measurement not supported');
                        }
                    }

                    // FID (First Input Delay) - simulate
                    let fidMeasured = false;
                    document.addEventListener('click', (event) => {
                        if (!fidMeasured) {
                            const fid = performance.now() - event.timeStamp;
                            this.metrics.coreWebVitals = this.metrics.coreWebVitals || {};
                            this.metrics.coreWebVitals.fid = fid;
                            this.log(`FID: ${fid.toFixed(2)}ms`);
                            fidMeasured = true;
                        }
                    }, { once: true });

                    // CLS (Cumulative Layout Shift)
                    let clsValue = 0;
                    const clsObserver = new PerformanceObserver((entryList) => {
                        for (const entry of entryList.getEntries()) {
                            if (!entry.hadRecentInput) {
                                clsValue += entry.value;
                            }
                        }
                        this.metrics.coreWebVitals = this.metrics.coreWebVitals || {};
                        this.metrics.coreWebVitals.cls = clsValue;
                        this.log(`CLS: ${clsValue.toFixed(4)}`);
                    });

                    if ('PerformanceObserver' in window) {
                        try {
                            clsObserver.observe({ entryTypes: ['layout-shift'] });
                        } catch (e) {
                            this.log('CLS measurement not supported');
                        }
                    }

                    // Resolve after a delay to allow measurements
                    setTimeout(() => {
                        resolve(this.metrics.coreWebVitals || {});
                    }, 2000);
                });
            }

            // Generate recommendations based on metrics
            generateRecommendations() {
                this.recommendations = [];

                // Page Load Recommendations
                if (this.metrics.pageLoad) {
                    if (this.metrics.pageLoad.totalLoadTime > 3000) {
                        this.recommendations.push({
                            priority: 'high',
                            category: 'Page Load',
                            issue: 'Slow page load time',
                            solution: 'Optimize images, minify CSS/JS, implement lazy loading',
                            metric: `${this.metrics.pageLoad.totalLoadTime.toFixed(2)}ms`
                        });
                    }

                    if (this.metrics.pageLoad.totalResourceSize > 1024 * 1024) { // > 1MB
                        this.recommendations.push({
                            priority: 'medium',
                            category: 'Resource Optimization',
                            issue: 'Large total resource size',
                            solution: 'Compress images, use WebP format, implement code splitting',
                            metric: `${(this.metrics.pageLoad.totalResourceSize / 1024 / 1024).toFixed(2)}MB`
                        });
                    }
                }

                // Animation Recommendations
                if (this.metrics.animation) {
                    if (this.metrics.animation.averageFPS < 30) {
                        this.recommendations.push({
                            priority: 'high',
                            category: 'Animation Performance',
                            issue: 'Low frame rate detected',
                            solution: 'Use CSS transforms instead of changing layout properties, reduce animation complexity',
                            metric: `${this.metrics.animation.averageFPS.toFixed(1)} FPS`
                        });
                    }

                    if (this.metrics.animation.memoryUsage && this.metrics.animation.memoryUsage.used > 50) {
                        this.recommendations.push({
                            priority: 'medium',
                            category: 'Memory Usage',
                            issue: 'High memory consumption',
                            solution: 'Optimize particle systems, reduce DOM complexity, implement object pooling',
                            metric: `${this.metrics.animation.memoryUsage.used}MB`
                        });
                    }
                }

                // Accessibility Recommendations
                if (this.metrics.accessibility) {
                    if (this.metrics.accessibility.imagesWithoutAlt > 0) {
                        this.recommendations.push({
                            priority: 'high',
                            category: 'Accessibility',
                            issue: 'Images without alt text',
                            solution: 'Add descriptive alt attributes to all images',
                            metric: `${this.metrics.accessibility.imagesWithoutAlt} images`
                        });
                    }
                }

                // Core Web Vitals Recommendations
                if (this.metrics.coreWebVitals) {
                    if (this.metrics.coreWebVitals.lcp > 2500) {
                        this.recommendations.push({
                            priority: 'high',
                            category: 'Core Web Vitals',
                            issue: 'Poor Largest Contentful Paint',
                            solution: 'Optimize largest image/text element, improve server response time',
                            metric: `LCP: ${this.metrics.coreWebVitals.lcp.toFixed(2)}ms`
                        });
                    }

                    if (this.metrics.coreWebVitals.cls > 0.1) {
                        this.recommendations.push({
                            priority: 'medium',
                            category: 'Core Web Vitals',
                            issue: 'High Cumulative Layout Shift',
                            solution: 'Set dimensions for images, avoid inserting content above existing content',
                            metric: `CLS: ${this.metrics.coreWebVitals.cls.toFixed(4)}`
                        });
                    }
                }

                return this.recommendations;
            }

            // Display metrics in the UI
            displayMetrics() {
                const grid = document.getElementById('metricsGrid');
                grid.innerHTML = '';

                const metricsData = [
                    {
                        title: 'Page Load Time',
                        value: this.metrics.pageLoad ? `${this.metrics.pageLoad.totalLoadTime.toFixed(2)}ms` : 'Not tested',
                        status: this.getLoadTimeStatus(this.metrics.pageLoad?.totalLoadTime),
                        description: 'Time from navigation start to page completion'
                    },
                    {
                        title: 'Animation FPS',
                        value: this.metrics.animation ? `${this.metrics.animation.averageFPS.toFixed(1)} FPS` : 'Not tested',
                        status: this.getFPSStatus(this.metrics.animation?.averageFPS),
                        description: 'Average frames per second during animations'
                    },
                    {
                        title: 'Memory Usage',
                        value: this.metrics.animation?.memoryUsage ? `${this.metrics.animation.memoryUsage.used}MB` : 'Not available',
                        status: this.getMemoryStatus(this.metrics.animation?.memoryUsage?.used),
                        description: 'JavaScript heap memory consumption'
                    },
                    {
                        title: 'Accessibility Score',
                        value: this.metrics.accessibility ? this.calculateA11yScore() : 'Not tested',
                        status: this.getA11yStatus(),
                        description: 'Accessibility compliance assessment'
                    },
                    {
                        title: 'LCP (Core Web Vital)',
                        value: this.metrics.coreWebVitals?.lcp ? `${this.metrics.coreWebVitals.lcp.toFixed(2)}ms` : 'Not measured',
                        status: this.getLCPStatus(this.metrics.coreWebVitals?.lcp),
                        description: 'Largest Contentful Paint performance'
                    },
                    {
                        title: 'Mobile Readiness',
                        value: this.metrics.mobile ? 'Tested' : 'Not tested',
                        status: this.getMobileStatus(),
                        description: 'Mobile performance and compatibility'
                    }
                ];

                metricsData.forEach(metric => {
                    const card = document.createElement('div');
                    card.className = 'metric-card';
                    card.innerHTML = `
                        <div class="metric-title">${metric.title}</div>
                        <div class="metric-value ${metric.status}">${metric.value}</div>
                        <div class="metric-description">${metric.description}</div>
                    `;
                    grid.appendChild(card);
                });
            }

            getLoadTimeStatus(time) {
                if (!time) return '';
                if (time < 1000) return 'good';
                if (time < 3000) return 'warning';
                return 'poor';
            }

            getFPSStatus(fps) {
                if (!fps) return '';
                if (fps >= 55) return 'good';
                if (fps >= 30) return 'warning';
                return 'poor';
            }

            getMemoryStatus(memory) {
                if (!memory) return '';
                if (memory < 30) return 'good';
                if (memory < 60) return 'warning';
                return 'poor';
            }

            getLCPStatus(lcp) {
                if (!lcp) return '';
                if (lcp < 2500) return 'good';
                if (lcp < 4000) return 'warning';
                return 'poor';
            }

            calculateA11yScore() {
                if (!this.metrics.accessibility) return 'Not tested';

                let score = 100;
                score -= this.metrics.accessibility.imagesWithoutAlt * 10;
                score -= this.metrics.accessibility.colorContrast.potentialIssues * 5;

                return `${Math.max(0, score)}/100`;
            }

            getA11yStatus() {
                const score = parseInt(this.calculateA11yScore());
                if (isNaN(score)) return '';
                if (score >= 80) return 'good';
                if (score >= 60) return 'warning';
                return 'poor';
            }

            getMobileStatus() {
                if (!this.metrics.mobile) return '';
                return this.metrics.mobile.viewport.isMobile ? 'good' : 'warning';
            }

            // Display results
            displayResults() {
                const results = document.getElementById('results');
                const content = document.getElementById('resultContent');

                results.style.display = 'block';

                const recommendations = this.generateRecommendations();

                let html = '<h4>üìä Performance Summary</h4>';
                html += `<p>Analysis completed with ${Object.keys(this.metrics).length} test categories.</p>`;

                if (recommendations.length > 0) {
                    html += '<h4>üîß Optimization Recommendations</h4>';
                    recommendations.forEach(rec => {
                        html += `
                            <div class="recommendation ${rec.priority}">
                                <strong>${rec.category}:</strong> ${rec.issue}<br>
                                <em>Solution:</em> ${rec.solution}<br>
                                <small>Metric: ${rec.metric}</small>
                            </div>
                        `;
                    });
                } else {
                    html += '<div class="recommendation low">üéâ No critical performance issues detected!</div>';
                }

                content.innerHTML = html;
            }
        }

        // Initialize analyzer
        const analyzer = new PerformanceAnalyzer();

        // Test functions
        async function runPageLoadTest() {
            analyzer.showProgressBar();
            analyzer.log('Starting page load analysis...');
            analyzer.updateProgress(25);

            await analyzer.analyzePageLoad();
            analyzer.updateProgress(100);
            analyzer.displayMetrics();
            analyzer.hideProgressBar();
        }

        async function runAnimationTest() {
            analyzer.showProgressBar();
            analyzer.log('Starting animation performance test...');
            analyzer.updateProgress(25);

            await analyzer.analyzeAnimations();
            analyzer.updateProgress(100);
            analyzer.displayMetrics();
            analyzer.hideProgressBar();
        }

        async function runMobileTest() {
            analyzer.showProgressBar();
            analyzer.log('Starting mobile performance analysis...');
            analyzer.updateProgress(50);

            await analyzer.analyzeMobilePerformance();
            analyzer.updateProgress(100);
            analyzer.displayMetrics();
            analyzer.hideProgressBar();
        }

        async function runAccessibilityTest() {
            analyzer.showProgressBar();
            analyzer.log('Starting accessibility analysis...');
            analyzer.updateProgress(50);

            await analyzer.analyzeAccessibility();
            analyzer.updateProgress(100);
            analyzer.displayMetrics();
            analyzer.hideProgressBar();
        }

        async function runCoreWebVitals() {
            analyzer.showProgressBar();
            analyzer.log('Measuring Core Web Vitals...');
            analyzer.updateProgress(30);

            await analyzer.analyzeCoreWebVitals();
            analyzer.updateProgress(100);
            analyzer.displayMetrics();
            analyzer.hideProgressBar();
        }

        async function runFullAnalysis() {
            analyzer.showProgressBar();
            analyzer.log('Starting comprehensive performance analysis...');

            analyzer.updateProgress(10);
            await analyzer.analyzePageLoad();

            analyzer.updateProgress(30);
            await analyzer.analyzeAnimations();

            analyzer.updateProgress(50);
            await analyzer.analyzeMobilePerformance();

            analyzer.updateProgress(70);
            await analyzer.analyzeAccessibility();

            analyzer.updateProgress(90);
            await analyzer.analyzeCoreWebVitals();

            analyzer.updateProgress(100);
            analyzer.displayMetrics();
            analyzer.displayResults();
            analyzer.hideProgressBar();

            analyzer.log('Full analysis completed!');
        }

        // Auto-run basic metrics on load
        window.addEventListener('load', () => {
            setTimeout(() => {
                runPageLoadTest();
            }, 1000);
        });
    </script>
</body>
</html>